1. 예외처리 (exception handling)

1.1 프로그램 오류
	- 에러
	- 프로그램 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우
	- 발생시점에 따른 분류
		- 컴파일 에러 (compile-time error)
			: 컴파일 할 때 발생하는 에러
			
		- 런타임 에러 (runtime error)
			: 프로그램 실행 도중 발생하는 에러
	
		- 논리적 에러 (logical error)
			: 컴파일도 잘되고 실행도 잘되지만, 의도한 것과 다르게 동작하는 것
		

	- 소스코드를 컴파일 하면, 컴파일러가 소스코드(.java)에 대해 기본적인 검사를 수행하여 오류를 알려준다. 이를 모두 수정해서 컴파일을 성공적으로 마치고 나면, 클래스 파일(.class)이 생성되고, 생성된 클래스 파일을 실행할 수 있게 된다.
	
	- 컴파일러는 실행도중 발생가능한 잠재적인 오류까지 검사할 수 없으므로, 컴파일은 잘되었어도 실행 중 에러에 의해 잘못된 결과를 얻을 수 있다.

	- 런타임 에러를 방지하기 위해서는 프로그램 실행도중 발생가능한 모든 경우의 수를 고려하여 이에 대한 대비를 하는 것이 필요

	- 자바에서는 실행 시 (runtime) 발생가능한 오류를 '에러(error)'와 '예외(exception)' 두 가지로 구분

	- 에러 
		: 메모리부족 (OutOfMemoryError)이나 스택오버플로우(StackOverflowError) 같이 일단 발생하면 복구할 수 없는 심각한 오류
		: 발생하면 프로그램의 비정상적인 종료를 막을 길이 없음
	- 예외
		: 수습가능한 비교적 덜 심각한 오류
		: 적절한 코드를 미리 작성하여 비정상적인 종료를 막을 수 있음


1.2 예외 클래스의 계층구조
	- 자바에서는 실행 시 발생할 수 있는 오류를 클래스로 정의
	- Exception과 Error클래스
	- Object클래스의 자손


	- Exception클래스
		- RuntimeException 클래스들
			: 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들
			: unchecked예외
				- 컴파일러가 예외처리를 확인하지 않음
			- 예시 
				- 배열의 범위를 벗어나는 경우 : ArrayIndexOutOfBoundsException
				- 값이 NULL인 참조변수의 멤버를 호출하려 한 경우 : NullPointerException
				- 클래스 간의 형변환을 잘못한 경우 : ClassCastException
				- 정수를 0으로 나누려고 한 경우 : ArithmeticException
 


		- Exception클래스들
			: RuntimeException을 제외한 클래스들
			: 주로 외부의 영향으로 발생할 수 있는 것들
			: 사용자들의 동작에 의해 발생하는 경우가 많음
			: checked예외
				- 컴파일러가 예외처리를 확인

			- 예시
				- 존재하지 않는 파일의 이름을 입력한 경우 : FileNotFoundException
				- 실수로 클래스의 이름을 잘못 적은 경우 : ClassNotFoundException
				- 입력한 데이터 형식이 잘못된 경우 : DataFormatException


1.3 예외 처리하기 : try-catch문

	- 프로그램 실행 도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해두어야 한다.
	- 예외 처리 (exception handling)
		- 정의 
			: 프로그램 실행 시 발생할 수 있는 예외에 대비한 코드를 작성
		- 목적
			: 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지
		
	- 발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되며, 처리하지 못한 예외(uncaught exception)은 JVM의 '예외처리기(UncaughtExceptionHandler)'가 받아서 에러 원인을 화면에 출력함
	- 에러 처리를 위해 try-catch문을 사용
	
	- 하나의 try블럭 다음에는 여러 종류의 예외를 처리하도록 하나 이상의 catch블럭이 올 수 있음
		: 이 중 발생한 예외의 종류와 일치하는 단 한 개의 catch블럭만 수행됨
		: 벌생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않음
	
	- try블럭 또는 catch블럭에 또 다른 try-catch문이 포함될 수 있음
		: catch블럭 내에서도 예외가 발생할 수 있기 때문
	- catch블럭 괄호 내에 선언된 변수는 catch블럭 내에서만 유효하므로 변수명이 겹쳐도 됨
		: 다만 catch블럭 내에 또 하나의 try-catch문이 포함된 경우, 같은 이름의 참조변수를 사용해서는 안됨. catch블럭 내 선언된 두 참조변수의 영역이 서로 겹치므로 다른 이름을 사용해야 서로 구별되기 때문


1.4 try-catch문에서의 흐름
	- try블럭 내에서 예외가 발생한 경우
		-> 발생한 예외와 일치하는 catch블럭이 있는지 확인한다
		---> 일치하는 catch블럭을 찾으면, 그 블럭 내의 문장들을 수행하고, 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다.		
		---> 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 않는다.
	
	- try블럭 내에서 예외가 발생하지 않은 경우
		- catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.


1.5 예외의 발생과 catch블럭
	- 예외 발생 -> 발생한 예외에 해당하는 인스턴스 생성 -> 해당 예외를 처라할 수 있는 catch블럭을 찾음 (instanceof 연산자를 이용하여 검사) -> 검사가 true인 catch블럭을 찾게되면 블럭 내 문장들을 모두 수행하고 try-catch문을 빠져나가 예외는 처리됨/  검사결과가 true인 블럭이 없다면 예외는 처리되지 않음

	- 모든 예외 클래스는 Exception클래스의 자손이므로, catch블럭의 괄호( )에 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해 처리됨.
		: 다만 첫번째 catch블럭에서 검사결과가 true인 경우 그 이후의 catch블럭 검사는 하지 않으므로, 두번쨰 블럭에 Exception클래스를 선언했더라도 처리되지 않음

		: 반대로 말하면, try-catch문 마지막에 Exception클래스 타입의 참조변수를 선언한 catch블럭을 사용하면, 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해 처리되도록 할 수 있다.

	- printStackTrace( )와 getMessage( )
		: 예외 발생 시 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있으며, getMessage와 printStackTrace를 통해서 이 정보들을 얻을 수 있다.

		- printStackTrace( )
			: 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력
		- getMessage( )
			: 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻어옴
		- catch블럭에 사용하여 예외의 발생원인을 알 수 있음

	- 멀티 catch블럭
		- JDK1.7부터 여러 catch블럭을 ' | ' 기호를 이용해서 하나의 catch블럭으로 합칠 수 있게 됨
		- 중복된 코드를 줄일 수 있음
		- ' | ' 기호로 연결할 수 있는 예외 클래스의 개수에는 제한이 없음
		- ' | ' 기호로 연결된 예외 클래스가 조상과 자손의 관계에 있다면 컴파일 에러 발생
			: 그냥 조상 클래스만 써주는 것과 똑같기 떄문. 불필요한 코드는 제거하라는 의미에서 에러가 발생
		- 멀티 catch블럭 내에서는 실제로 어떤 예외가 발생한 것인지 알 수 없음
		- 예외클래스들의 공통 분모인 조상 클래스를 참조변수로 사용할 수 있음

1.6 예외 발생시키기

	- 키워드 ' throw '를 사용하여 프로그래머가 고의로 예외를 발생시킬 수 있음
	- 방법
		- new 연산자를 이용해서 발생시키려는 예외 클래스의 객체를 만든다
		-> 키워드 throw를 이용해서 예외를 발생시킨다

	- Exception인스턴스 생성 시, 생성자에 String을 넣어주면, 이 String이 Exception 인스턴스에 메시지로 저장된다.



1.7 메서드에 예외 선언하기
	- try-catch외에 예외를 처리하는 방법 = 예외를 메서드에 선언하는 방법
	- 방법
		: 메서드 선언부에 키워드 throws를 사용해서 메서드 내에서 발생가능한 예외를 적어줌
		: 예외가 여러 개일 경우 쉼표로 구분

## 예외를 발생시키는 키워드 throw 와  예외를 메서드에 선언하는 throws를 구분할 것
	
	- throws Exception 
		: 이 메서드에서 모든 종류의 예외가 발생할 가능성이 있다는 뜻
	- 메서드 선언부를 보았을 때 이 메서드를 사용하기 위해 어떠한 예외들이 처리되어야 하는지 쉽게 알 수 있다.
	
	- 일반적으로 RuntimeException클래스들은 적지 않는다.
		: 선언한다고 문제는 안되지만, 보통은 반드시 처리해주어야 하는 예외들만 선언함
	- throws에 예외를 명시하는 것은, 예외를 처리하는 것이 아니라, 해당 메서드가 자신을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것
		: 이를 전달받은 메서드가 또다시 자신을 호출한 메서드에게 전달할 수 있으며, 이런 식으로 호출스택의 메서드들을 따라 전달되다가 제일 마지막의 main메서드에서도 예외 처리가 되지 않으면, main메서드마저 종료되어 프로그램 전체가 종료된다.
			-> 결국 어느 한 곳에서는 반드시 try-catch문으로 예외처리를 해주어야 한다.
	
	- 예외가 발생한 메서드 내에서 자체적으로 처리해도 되는 것은, 메서드 내에서 try-catch문을 사용하여 처리
	- 메서드 호출 시 넘겨받아야 할 값을 다시 받아야 하는 경우 (메서드 내에서 자체적으로 해결이 안 되는 경우) 예외를 메서드에 선언해서, 호출한 메서드에서 처리

1.8  finally 블럭
	- 예외의 발생여부에 상관없이 실행되어야 할 코드를 포함시킬 목적으로 사용
	- try-catch문의 끝에 선택적으로 붙여 사용
	- 예외가 발생한 경우 : try->catch->finally 순으로 실행
	- 예외가 발생하지 않은 경우 : try -> finally 순으로 실행
	
	- try문 또는 catch문에서 return문을 만나도, finally블럭의 문장들은 수행된다.

1.9 자동 자원 반환 : try - with - resource

	- JDK 1.7부터 try-catch문의 변형으로 새로 추가됨
	
	- 주로 입출력에 사용되는 클래스 중에는 사용한 후 꼭 닫아줘야 하는 것들이 있음 : 그래야 사용했던 자원(resource)가 반환되기 때문
	- 