7.1 인터페이스란?
	- 일종의 추상클래스
	- 추상클래스보다 추상화 정도가 높아서, 멤버변수 및 몸통만 갖춘 일반 메서드를 가질 수 없다.
		: 오직 추상메서드와 상수만 멤버로 가질 수 있음
	- 구현된 것은 아무것도 없고 밑그림만 그려져 있는 '기본 설계도'
	- 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성


7.2 인터페이스의 작성
	- 키워드 : interface
	- 접근제어자로 public 또는 default 사용 가능
	- 인터페이스 멤버의 제약사항
		1) 멤버변수
			: public static final 이어야 함
			: 생략 가능 (컴파일러가 자동으로 위의 접근제어자를 추가)
		2) 메서드
			: public abstract 이어야 함
			: 생략 가능 (컴파일러가 자동으로 위의 접근제어자를 추가)
			: 단, static 메서드와 default 메서드는 예외
				-> 원래 인터페이스의 모든 메서드는 추상메서드이어야 하는데, JDK1.8부터 인터페이스에 static메서드와 default메서드의 추가를 허용하는 방향으로 변경되었다.
			
				-> 실무에서는 1.8이전도 사용하므로, 이전 규칙도 알아야 함

	
7.3 인터페이스의 상속
	- 인터페이스는 인터페이스로부터만 상속받을 수 있다.
	- 클래스와 달리, 다중상속, 즉 여러 인터페이스로부터 상속받는 것이 가능

# 인터페이스는 클래스와 달리, Object클래스와 같은 최고 조상이 없다.
	

7.4 인터페이스의 구현
	- 인터페이스도 추상클래스와 마찬가지로 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 함
	- 다만 클래스는 확장한다는 의미의 'extends'를 사용하지만, 인터페이스는 구현한다는 의미의 키워드 'implements'를 사용함

	- 만일 인터페이스 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 함

	- extends와 implements를 함께 써서 상속과 구현을 동시에 할 수도 있다.
	
# 인터페이스 이름에는 주로 '~을 할 수 있는'의 의미인 'able'로 끝나는 것들이 많음
	## 그 이유는 어떠한 기능/행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서임.
	## 또한 그 인터페이스를 구현한 클래스는 '~을 할 수 있는' 능력을 갖추었다는 의미이기도 함
	

	- 인터페이스는 상속 대신 구현이라는 용어를 사용하지만, 인터페이스로부터 상속받은 추상메서드를 구현하는 것이기 때문에 조금 다른 의미의 조상이라고 할 수 있다.
	
	- 인터페이스를 구현한 메서드의 접근 제어자는 반드시 public이 된다
		- 오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야 한다 (규칙)
		- 인터페이스의 메서는 public abstract이므로 (생략하더라도), 이를 구현하는 클래스의 메서드는 public을 쓸 수 밖에 없다.



7.5 인터페이스를 이용한 다중상속
	- Java가 다중상속을 포기한 이유
		: 두 조상으로부터 상속받는 멤버 중에서 멤버변수의 이름이 같거나, 메서드의 선언부가 일치하고 구현 내용이 다르다면, 이 두 조상으로부터 상속받는 자손클래스는 어느 조상의 것을 상속받게 되는 것인지 알 수 없다. 
		: 어느 한 쪽으로부터의 상속을 포기하던가

7.6 인터페이스를 이용한 다형성 

	- 클래스의 다형성 부분에서처럼, 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다. 
	- 인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것이다.

	- 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

7.7 인터페이스의 장점
	- 개발시간 단축
		: 일단 인터페이스가 작성되면. 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호 출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문이다. 그리고 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하게 하면. 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.

	- 표준화 가능
		: 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하 여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.

	- 서로 관계없는 클래스들에게 관계를 맺어줌
		: 서로 상속관계에 있지도 않고. 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클 래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.


	- 독립적인 프로그래밍이 가능
		: 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용 해서 간접적인 관계로 변경하면. 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.


7.8 인터페이스의 이해
	
	- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다,
	- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.

7.9 디폴트 메서드와 static메서드
	- 원래는 인터페이스에 추상 메서드만 선언 가능
	- JDK1.8부터 디폴트 메서드와 static메서드도 추가할 수 있게 됨
	- 인터페이스의 static메서드 역시 접근 제어자가 항상 public이며, 생략할 수 있다.
	
	- 디폴트 메서드
		- 인터페이스가 변경되는 것은 큰 일이다
			: 인터페이스에 메서드를 추가한다 = 추상메서드를 추가한다 = 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야 한다.
		- 디폴트 메서드 (default method)
			: 추상 메서드의 기본적인 구현을 제공하는 메서드
			: 추상 메서드가 아니므로 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 됨
			: 앞에 키워드 'default'를 붙이며, 추상 메서드와 달리 일반 메서드처럼 몸통 ( { } ) 이 있어야 함.
			: 디폴트 메서드 역시 접근 제어자가 public이며, 생략 가능하다.
		
			- 새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우, 충돌을 해결하는 규칙
				- 여러 인터페이스의 디폴트 메서드 간의 충돌
					: 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
				- 디폴트 메서드와 조상 클래스 메서드 간의 충돌
					: 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
				
				- 규칙이 외우기 귀찮으면, 그냥 필요한 쪽의 메서드와 같은 내용으로 오버라이딩 해버리면 그만이다.




