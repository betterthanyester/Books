4.1 제어자란 (modifier) ?
	
	- 의미
		: 클래스/변수/메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
	
	- 종류
		1) 접근제어자
			: public, protected, default, private
		
		2) 그 외
			: static, final, abstract, native, transient, synchronized, volatile, strictfp

	- 접근 제어자는 한번에 4가지 중 하나만 선택해서 사용 가능
	- 그 외에는 하나의 대상에 대해 여러 제어자를 조합하여 사용 가능

	
## 제어자들 간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.



4.2 static - 클래스의, 공통적인
	
	- 의미
		- '클래스의' , '공통적인'
		- 인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지
		- 클래스 변수 (static멤버변수)는 인스턴스에 관계없이 같은 값을 가짐
			: 이는 하나의 변수를 모든 인스턴스가 공유하기 때문
	- 특징
		- static이 붙은 멤버변수/메서드/초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에, 인스턴스를 생성하지 않고도 사용할  수 있다.
		- static메서드는 인스턴스메서드와 달리 메서드 내에서 인스턴스 멤버를 사용하지 않음
			: 인스턴스 멤버를 사용하지 않는 메서드는 static메서드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 더 빠르다.



## static초기화 블럭은 클래스가 메모리에 로드될 매 단 한번만 수행되며. 주로 클래스변수 (static변수)를 초기화하는 데 주로 사용된다.




4.3 final - 마지막의, 변경될 수 없는
	
	- 의미
		: '마지막의', '변경될 수 없는'
	
	- 특징
		- 변수에 사용되면 
			: 값을 변경할 수 없는 상수가 됨
		- 메서드에 사용되면
			: 오버라이딩을 할 수 없게 됨
		- 클래스에 사용되면
			: 자신을 확장하는 자손클래스를 정의하지 못하게 됨
		
	- final 멤버 변수의 초기화 : 생성자 이용
		-  final 변수는 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 final이 붙더라도 생성자에서 초기화할 수 있다 (static 변수는 불가).

		- 모든 인스턴스(객체)들이 같은 값을 가지지 않지만, 일단 생성이 되면 바뀌어서는 안되는 변수를 final 인스턴스 변수로 지정하고
			: ex) 카드의 문양 종류와 숫자
		- 모든 인스턴스(객체)들이 같은 값을 가져야 하는 변수는 static final 변수로 지정
			: ex) 카드의 가로,세로 규격 




4.4 abstract - 추상의, 미완성의
	- 의미
		: '미완성'
	
	- 용도
		- 메서드에 사용되는 경우
			: 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
		- 클래스에 사용되는 경우
			: 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 함
	


4.5 접근 제어자 (access modifier)
	
	- 역할
		: 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
	- 특징
		- 사용될 수 있는 곳 : 클래스, 멤버변수, 메서드, 생성자
		- default임을 알리기 위해 실제로 default를 붙이지는 않는다. 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.
	- 종류
		- private 
			: 같은 클래스 내에서만 접근이 가능하다.
		- default 
			: 같은 패키지 내에서만 접근이 가능하다.
		- protected 
			: 원래는 패키지에 관계없이 상속관계에 있는 자손클래스에서 접근이 가능하다.
			: 다만 같은 패키지 내에서는 상속관계가 아니더라도 접근이 가능하다. 
		- public
			: 접근 제한이 전혀 없다.



	- 접근 범위 - 넓은 쪽 >>> 좁은 쪽
		: public > protected > (default) > private


	- 접근 제어자를 이용한 '캡슐화'
		- 접근 제어자를 사용하는 이유
			- 외부로부터 데이터를 보호하기 위해서
			- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
	
			- 접근 제어자를 적절히 선택해서 접근 범위를 최소화하여, 변경이나 오류로 인한 수정 범위를 제한할 수 있다
				: 만일 메서드 하나를 변경해야 한다고 가정했을 때. 이 메서드의 접근 제어자가 public이라면, 메서드를 변경한 후에 오류가 없는지 테스트해야하는 범위가 넓다. 그러나 접근 제어자가 default라면 패키지 내부만 확인해 보면 되고, private이면 클래스 하나만 살펴보면 된다. 이처럼 접근 제어자 하나가 때로는 상당한 차이를 만들어낼 수 있다. 

		- 방식
			- 멤버변수를 private이나 protected로 제한하고, 멤버변수 값을 읽고 변경할 수 있는 public메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 하는 것이 바람직하다.
				- getter
					- get으로 시작하는 메서드
					- 단순히 멤버변수의 값을 반환하는 일을 함
				- setter
					- set으로 시작하는 메서드
					- 매개변수에 지정된 값을 검사하여 조건에 맞는 값일 때만 멤버변수의 값을 변경
				- 상속을 통해 확장될 것이 예상되는 클래스라면, 자손클래스에서 멤버에 접근하는 것이 가능하도록 하기 위해 private 대신 protected를 사용
					: private가 붙은 멤버 변수는 자손클래스에서도 접근이 불가능하기 때문
				- 
			
			 


	- 생성자의 접근 제어자
		- 용도
			- 생정자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한
			- 보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정도 가능
			- private으로 지정하면
				1)  외부에서 생성자에 접근 불가 -> 인스턴스 생성불가
					: 클래스 내부에서는 인스턴스 생성 가능
					: 인스턴스를 생성해서 반환해주는 public메서드를 제공하여 외부에서 인스턴스 생성가능
						-> 다만 이 메서드는 public인 동시에 static이어야 함
						-> 왜냐하면, 인스턴스 생성 없이도 호출할 수 있어야 하기 때문
				2) 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다.
					: 왜냐하면, 자손클래스의 인스턴스 생성 시 조상클래스의 생성자를 호출해야 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능하기 때문
					: 따라서 생성자가 private인 클래스는 앞에 final을 추가하여 상속할 수 없는 클래스임을 알리는 것이 좋다.





4.6 제어자(modifier)의 조합
	- 제어자 조합 시 주의할 사항
		1) 메서드에 static과 abstract를 함께 사용할 수 없다
			: static메서드는 몸통이 있는 메서드에서만 사용할 수 있기 때문
		
		2) 클래스에 abstract와 final을 동시에 사용할 수 없다
			: 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문
		
		3) abstract메서드의 접근 제어자가 private일 수 없다.
			: abstract메서드는 자손클래스에서 구현해주어야 하는데, 접근 제어자가 private이면 자손클래스에서 접근할 수 없기 때문

		4) 메서드에 private와 final을 같이 사용할 필요는 없다.
			: 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문. 둘 중 하나만 사용해도 의미가 충분하다.







